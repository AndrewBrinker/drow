#!/usr/bin/env bash

set -u

main () {
    local build="./.build"
    local assets="./assets"
    local pages="./pages"
    local posts="./posts"
    local static="./static"
    local templates="./templates"

    if [ -d "$build" ]; then
        say "Cleaning previous build out."
        rm -r "$build"
    fi

    say "Creating build directory."
    ensure mkdir -p "$build"

    say "Copying assets."
    ensure cp -r "$assets" "$build"

    say "Copying static files."
    ensure cp -R "$static/." "$build"

    say "Building pages."
    for file in $pages/*; do
        local ident=$(basename $file .md)
        local output="$build/$ident/index.html"

        if [ "$ident" = "index" ]; then
            output="$build/index.html"
        fi

        ensure pandoc --template "$templates/main.html" \
                      -f markdown \
                      -t html \
                      -o "$output" \
                      "$file"
    done
}

say() {
    echo "drow: $1"
}

say_err() {
    say "$1" >&2
}

err() {
    say "$1" >&2
    exit 1
}

need_cmd() {
    if ! command -v "$1" > /dev/null 2>&1
    then err "need '$1' (command not found)"
    fi
}

need_ok() {
    if [ $? != 0 ]; then err "$1"; fi
}

assert_nz() {
    if [ -z "$1" ]; then err "assert_nz $2"; fi
}

# Run a command that should never fail. If the command fails execution
# will immediately terminate with an error showing the failing
# command.
ensure() {
    "$@"
    need_ok "command failed: $*"
}

# This is just for indicating that commands' results are being
# intentionally ignored. Usually, because it's being executed
# as part of error handling.
ignore() {
    run "$@"
}

# Runs a command and prints it to stderr if it fails.
run() {
    "$@"
    local _retval=$?
    if [ $_retval != 0 ]; then
        say_err "command failed: $*"
    fi
    return $_retval
}

main $@ || exit 1

